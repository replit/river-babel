# ruff: noqa
# Code generated by river.codegen. DO NOT EDIT.
from collections.abc import AsyncIterable, AsyncIterator
import datetime
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Mapping,
    Union,
    Tuple,
    TypedDict,
)

from pydantic import BaseModel, Field, TypeAdapter
from replit_river.error_schema import RiverError

import replit_river as river


class KvSetInput(BaseModel):
    k: str
    v: float


class KvSetOutput(BaseModel):
    v: int


class KvWatchInput(BaseModel):
    k: str


class KvWatchOutput(BaseModel):
    v: float


class KvWatchErrors(RiverError):
    code: Literal["NOT_FOUND"]
    message: str


class KvService:
    def __init__(self, client: river.Client[Literal[None]]):
        self.client = client

    async def set(
        self,
        input: KvSetInput,
    ) -> KvSetOutput:
        return await self.client.send_rpc(
            "kv",
            "set",
            input,
            lambda x: TypeAdapter(KvSetInput).dump_python(
                x,  # type: ignore[arg-type]
                by_alias=True,
                exclude_none=True,
            ),
            lambda x: TypeAdapter(KvSetOutput).validate_python(
                x  # type: ignore[arg-type]
            ),
            lambda x: TypeAdapter(RiverError).validate_python(
                x  # type: ignore[arg-type]
            ),
        )

    async def watch(
        self,
        input: KvWatchInput,
    ) -> AsyncIterator[Union[KvWatchOutput, KvWatchErrors]]:
        return await self.client.send_subscription(
            "kv",
            "watch",
            input,
            lambda x: TypeAdapter(KvWatchInput).dump_python(
                x,  # type: ignore[arg-type]
                by_alias=True,
                exclude_none=True,
            ),
            lambda x: TypeAdapter(KvWatchOutput).validate_python(
                x  # type: ignore[arg-type]
            ),
            lambda x: TypeAdapter(KvWatchErrors).validate_python(
                x  # type: ignore[arg-type]
            ),
        )


class RepeatEchoInput(BaseModel):
    str: str


class RepeatEchoOutput(BaseModel):
    out: str


class RepeatEcho_PrefixInit(BaseModel):
    prefix: str


class RepeatEcho_PrefixInput(BaseModel):
    str: str


class RepeatEcho_PrefixOutput(BaseModel):
    out: str


class RepeatService:
    def __init__(self, client: river.Client[Literal[None]]):
        self.client = client

    async def echo(
        self,
        inputStream: AsyncIterable[RepeatEchoInput],
    ) -> AsyncIterator[Union[RepeatEchoOutput, RiverError]]:
        return await self.client.send_stream(
            "repeat",
            "echo",
            None,
            inputStream,
            None,
            lambda x: TypeAdapter(RepeatEchoInput).dump_python(
                x,  # type: ignore[arg-type]
                by_alias=True,
                exclude_none=True,
            ),
            lambda x: TypeAdapter(RepeatEchoOutput).validate_python(
                x  # type: ignore[arg-type]
            ),
            lambda x: TypeAdapter(RiverError).validate_python(
                x  # type: ignore[arg-type]
            ),
        )

    async def echo_prefix(
        self,
        init: RepeatEcho_PrefixInit,
        inputStream: AsyncIterable[RepeatEcho_PrefixInput],
    ) -> AsyncIterator[Union[RepeatEcho_PrefixOutput, RiverError]]:
        return await self.client.send_stream(
            "repeat",
            "echo_prefix",
            init,
            inputStream,
            lambda x: TypeAdapter(RepeatEcho_PrefixInput).validate_python,
            lambda x: TypeAdapter(RepeatEcho_PrefixInput).dump_python(
                x,  # type: ignore[arg-type]
                by_alias=True,
                exclude_none=True,
            ),
            lambda x: TypeAdapter(RepeatEcho_PrefixOutput).validate_python(
                x  # type: ignore[arg-type]
            ),
            lambda x: TypeAdapter(RiverError).validate_python(
                x  # type: ignore[arg-type]
            ),
        )


UploadSendInputPart = Union[str, Literal["EOF"]]


class UploadSendInput(BaseModel):
    part: UploadSendInputPart


class UploadSendOutput(BaseModel):
    doc: str


class UploadService:
    def __init__(self, client: river.Client[Literal[None]]):
        self.client = client

    async def send(
        self,
        inputStream: AsyncIterable[UploadSendInput],
    ) -> Union[UploadSendOutput, RiverError]:
        return await self.client.send_upload(
            "upload",
            "send",
            None,
            inputStream,
            None,
            lambda x: TypeAdapter(UploadSendInput).dump_python(
                x,  # type: ignore[arg-type]
                by_alias=True,
                exclude_none=True,
            ),
            lambda x: TypeAdapter(UploadSendOutput).validate_python(
                x  # type: ignore[arg-type]
            ),
            lambda x: TypeAdapter(RiverError).validate_python(
                x  # type: ignore[arg-type]
            ),
        )


class TestCient:
    def __init__(self, client: river.Client[Literal[None]]):
        self.kv = KvService(client)
        self.repeat = RepeatService(client)
        self.upload = UploadService(client)
